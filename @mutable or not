    public class ImmutableStrings   
    {  
      
    // main method  
    public static void main(String argvs[])   
    {  
    String str1 = "dadi";  
    // assigning the reference of string str1 to string str2   
    String str2 = str1;   
    str1 = str1 + "Gulzar";  
      
    if(str1 == str2)  
    {  
    System.out.println("Strings are not immutable.");  
    }  
    else  
    {  
    // if the control reaches here, then it means == operator   
    // has returned a false value.  
    System.out.println("Strings are immutable.");      
    }  
          
      
    }  
    }  

Output:

Strings are immutable.

8) Print reverse array in Java using recursion for the given input array without using any extra space. Ignore the implicit stack used in recursion for computing the space complexity.

FileName: ReverseArrUsingRec.java

    import java.util.*;  
    public class ReverseArrUsingRec   
    {  
    public static void revArr(int arr[], int size, int i)  
    {  
    // handling the base case  
    if(i >= size)  
    {  
        return;  
    }  
      
    // recursively printing the input array  
    // in the reverse order  
    revArr(arr, size, i + 1);  
    System.out.print(arr[i] + " ");  
      
    }  
      
    // main method  
    public static void main(String argvs[])   
    {  
    Scanner scn = new Scanner(System.in);  
      
    int n = scn.nextInt();  
      
    int intArr[] = new int[n];  
      
    // user to enter the elements  
    for(int i = 0; i < n; i++)   
    {  
        intArr[i] = scn.nextInt();  
    }  
      
    System.out.println("The input array is:");  
      
    // loop for displaying the input array  
    for(int it = 0; it < intArr.length; it++)   
    {  
        System.out.print(intArr[it] + " ");  
    }  
    System.out.println(" \n");  
      
    System.out.println("The reversed array is:");  
      
    revArr(intArr, intArr.length, 0);  
      
    }  
    }  

Input:

    4  
    8  
    5  
    90  
    23  

Output:

The input array is:
8 5 90 23  

The reversed array is:
23 90 5 8

Input:

    6  
    45  
    12  
    21  
    78  
    60  
    66  

Output:

The input array is:
45 12 21 78 60 66  

The reversed array is:
66 60 78 21 12 45

Complexity Analysis: The time complexity of the program is O(num), where num is the total number of elements present in the input array. The space complexity of the program is constant, which is O(1).
9) Write a Java program for finding the index of the first as well as the last occurrence of an element in the array using linear time without using any extra space. Consider one indexing.

FileName: FindEle.java

    import java.util.*;  
    public class FindEle   
    {  
      
    public static int[] findIndexOfReqEle(int inputArr[], int tar)  
    {  
    // size of the input array.  
    int size = inputArr.length;  
      
    // array for storing the first and the last index  
    int ansArr[] = new int[2];  
    ansArr[0] = -1;  
    ansArr[1] = -1;  
      
    // flag for checking whether the target element   
    // exists or not  
    boolean isEleFound = false;  
      
    // loop for searching the required element  
    for(int k = 0; k < size; k++)   
    {  
    if(inputArr[k] == tar)   
    {  
    if(!isEleFound)   
    {  
        // k + 1 because of the one indexing  
        ansArr[0] = k + 1;  
        ansArr[1] = k + 1;  
          
        // required element found for the first time   
        isEleFound = true;   
    }   
      
    else   
    {  
        // required element is present in the array at least twice.  
        ansArr[1] = k + 1;  
    }  
    }  
    }  
      
    return ansArr;  
    }  
      
    // main method  
    public static void main(String argvs[])   
    {  
    System.out.println("Enter size of the input array");  
    Scanner scnr = new Scanner(System.in);  
    int num = scnr.nextInt();  
    int[] intArr = new int[num];  
      
    System.out.println("Enter elements of the input array");  
      
    // input the array  
    for(int k = 0; k < num; k++)   
    {  
        intArr[k] = scnr.nextInt();  
    }  
      
    System.out.println("Enter target element to be searched.");  
    int targetEle = scnr.nextInt();  
      
    int ansArr[] = findIndexOfReqEle(intArr, targetEle);  
      
      
      
    if(ansArr[0] == -1)   
    {  
        System.out.println("In the input array, the element " + targetEle + " does not exist.");  
    }   
      
    else   
    {  
        System.out.println("For the target element: " + targetEle + ", First Index = " + ansArr[0] + " Last Index = " + ansArr[1]);  
    }  
    }  
    }  

Input:

    Enter size of the input array  
    7  
    Enter elements of the input array  
    45  
    12  
    21  
    78  
    60  
    66  
    60  
    Enter target element to be searched.  
    60  

Output:

For the target element: 60, First Index = 5 Last Index = 7

Input:

    Enter size of the input array  
    4  
    Enter elements of the input array  
    34  
    12  
    21  
    20  
    Enter target element to be searched.  
    12  

Output:

For the target element: 12, First Index = 2 Last Index = 2

Input:

    Enter size of the input array  
    5  
    Enter elements of the input array  
    34  
    55  
    21  
    2  
    80  
    Enter target element to be searched.  
    27  

Output:

In the input array, the element 27 does not exist.

Complexity Analysis: The time complexity of the program is O(num), where num is the total number of elements present in the input array. The space complexity of the program is constant, which is O(1).

Corner Case: We have to take care of the case where the target element is not present in the array. It is because the index of the element becomes irrelevant if the element is absent.
10) Write a Java program to display the elements of the matrix in the Wave Order as mentioned below. (The matrix can have different numbers of columns and rows).
Java Coding Interview Questions

By observing the image, it is evident that for columns that are even, the traversal is top to down, and when the columns are odd, the traversal is bottom to top direction.

FileName: WaveOrder.java

    import java.io.*;  
    import java.util.*;  
      
    public class WaveOrder  
    {  
      
    // main method  
    public static void main(String argvs[]) throws Exception   
    {  
      
    Scanner scnr = new Scanner(System.in);  
      
    System.out.println("Enter row: ");  
    int r = scnr.nextInt();  
      
    System.out.println("Enter column: ");  
    int c = scnr.nextInt();  
      
    int[][] matrx = new int[r][c];  
      
    System.out.println("Enter the elements of the matrix: ");  
    // input the matrix  
    for(int i=0; i < r; i++)   
    {  
    for(int j=0; j < c; j++)   
    {  
        matrx[i][j] = scnr.nextInt();  
    }  
    }   
      
    System.out.println("\n");  
    System.out.println("The wave order traversal of the input matrix is: ");  
      
    // loop for traversing the input array in the wave order  
    for(int j = 0; j < matrx[0].length; j++)   
    {  
    // for top to down direction for the even columns  
    if(j % 2 == 0)   
    {  
        for(int i = 0; i < matrx.length; i++)   
        {  
            System.out.print(matrx[i][j] + " ");  
        }  
    }   
      
    // for down to to direction for the odd columns  
    else   
    {  
        for(int i = matrx.length - 1; i >= 0; i--)   
        {  
            System.out.print(matrx[i][j] + " ");  
        }  
    }  
    System.out.println();  
    }   
    }  
      
    }  

Input:

    Enter row:   
    3  
    Enter column:   
    3  
    Enter the elements of the matrix:   
    4 3 1  
    9 0 7  
    5 6 2  

Output:

The wave order traversal of the input matrix is: 
4 9 5
6 0 3 
1 7 2

Input:

    Enter row:   
    4  
    Enter column:   
    4  
    Enter the elements of the matrix:   
    41 13 21 30  
    49 20 27 12  
    51 16 62 36  
    76 32 29 63  

Output:

The wave order traversal of the input matrix is: 
41 49 51 76 
32 16 20 13 
21 27 62 29 
63 36 12 30

Complexity Analysis: The time complexity of the program is O(r x c), where r is the row size and c is the column size. The space complexity of the program is constant, which is O(1).
11) Implement a class "Developer". Write some methods and properties to it and find how one will use them in the main method by instantiating the class.

Observe the following example.

FileName: TestClass.java

    import java.util.*;  
      
    class Developer   
    {  
      
    private int devAge;  
    private String devName;  
      
    // parameterless constructor   
    // of the class  
    Developer()   
    {  
      
    }  
      
    // parameterized constructor of the class  
    Developer(int devAge, String devName)   
    {  
        this.devAge = devAge;  
        this.devName = devName;  
    }  
      
    // for setting the age  
    void setAge(int devAge)   
    {  
        this.devAge = devAge;  
    }  
      
    // for setting name  
    void setName(String devName)   
    {  
        this.devName = devName;  
    }  
      
    // for retriving age  
    int getAge()   
    {  
        return devAge;  
    }  
      
    // for retriving name  
    String getName()   
    {  
        return devName;  
    }  
      
      
    public void writeCode()   
    {  
        System.out.println(this.devName + " writes codes.");  
    }  
      
    public void drinksTea()   
    {  
        System.out.println(this.devName + " drinks tea and then convert the quadratic complexity codes to linear.");  
    }  
    }  
      
    public class TestClass  
    {  
    // main method  
    public static void main(String argvs[])   
    {  
        // creating an object of the class Developer  
        Developer d1 = new Developer(32, "Shiva");  
          
        // invoking the methods writeCode(), and drinksTea()  
        d1.writeCode();  
        d1.drinksTea();  
    }  
    }  

Output:

Shiva writes code.
Shiva drinks tea and then convert the quadratic complexity codes to linear.

Explanation: Some things you should keep in mind: The properties must usually be set private, and we should have getter and setter methods to access and modify them. This is good OOPS practice. Also, always create a default constructor, as when we create a parameterized constructor, Java removes its own default constructor, and object creation without passing the parameters to the constructor would not be possible.
12) Write a Java program to count the consonants and vowels present in the input string. The string may contain numeric characters, and only lowercase letters are allowed in the input string.

FileName: CountVowelConst.java

    import java.util.*;  
      
    // the main class  
    public class CountVowelConst  
    {  
          
    // the following method checks whether the   
    // character chr is a vowel or a consonant  
    public static boolean isVowelChar(char chr)   
    {  
        // an array that contains only vowels  
        char charArr[] = new char[5];  
        charArr[0] = 'a';  
        charArr[1] = 'e';  
        charArr[2] = 'i';  
        charArr[3] = 'o';  
        charArr[4] = 'u';  
          
        for(int g = 0; g < 5; g++)  
        {  
            if(chr == charArr[g])  
            {  
                return true;  
            }  
        }  
          
        // if the control reaches here then it means  
        // the character is not vowel  
        return false;  
    }  
      
    // main method  
    public static void main(String argvs[])   
    {  
      
        Scanner scnr = new Scanner(System.in);  
        String strng = scnr.nextLine();  
      
        int vCount = 0;  
        int cCount = 0;  
      
        for(int i = 0; i < strng.length(); i++)   
        {  
            char chr = strng.charAt(i);  
            if(isVowelChar(chr) == true)   
            {  
                vCount = vCount + 1;  
            }  
              
            // for consonent it is necessary for the character to be an alphabet  
            else if(chr >='a' && chr <='z' && (isVowelChar(chr) == false))   
            {  
                cCount = cCount + 1;  
            }  
        }  
      
        System.out.println("Count of vowels in the String : '" + strng + "' is: " + vCount);  
        System.out.println("Count of consonants in the String : '" + strng + "' is: " + cCount);  
        System.out.println("Count of other characters in the String : '" + strng + "' is: " + (int)(strng.length() - vCount - cCount));  
    }  
    }  

Input:

    abcd44iut  

Output:

Count of vowels in the String : 'abcd44iut' is: 3
Count of consonants in the String : 'abcd44iut' is: 4
Count of other characters in the String : 'abcd44iut' is: 2

Input:

    aoiue  

Output:

Count of vowels in the String : 'aoiue' is: 5
Count of consonants in the String : 'aoiue' is: 0
Count of other characters in the String : 'aoiue' is: 0

Input:

    aoiue  

Output:

Count of vowels in the String : 'aoiue' is: 5
Count of consonants in the String : 'aoiue' is: 0
Count of other characters in the String : 'aoiue' is: 0

Input:

    @51#$%290(){}  

Output:

Count of vowels in the String : '@51#$%290(){}' is: 0
Count of consonants in the String : '@51#$%290(){}' is: 0
Count of other characters in the String : '@51#$%290(){}' is: 13

Corner Cases: One might miss the case that what will happen if the string contains some numbers or special characters like '0', '5', '#', '@', etc. These characters are neither vowels nor consonants. For characters like these, separate handling is required. Generally, candidates find the vowels count and then subtract it from the size of the string to find consonants, which will give the wrong result if the string contains some characters that are not alphabetical.

Complexity Analysis: The time complexity of the program is O(n), where n is the total number of characters present in the input string. The space complexity of the program is O(1) as the program uses the array of size 5, which will not change if we change the input string.
13) Write a Java program to demonstrate inheritance.

The following program demonstrates inheritance with the help of extends keyword. The following program shows a SmartPhone class that extends the Mobile class and has the features like playing and stopping music player, making a call, taking photos, etc.

FileName: TestInheritance.java

    class Mobile   
    {  
      
    private int num;  
      
    // class constructor  
    Mobile()   
    {  
      
    }  
      
    void setNumber(int num)   
    {  
        this.num = num;  
    }  
      
    int getNumber()   
    {  
        return num;  
    }  
      
    public void doCall()   
    {  
        System.out.println("Calling the dialled number.");  
    }  
      
    public void receiveMessage() {  
        System.out.println("The Message is received.");  
    }  
      
    }  
      
    // child class SmrtPhone inheriting the parent class Mobile  
    class SmrtPhone extends Mobile   
    {  
      
    int cameraMegaPX;  
      
    public void clickPhoto()   
    {  
        System.out.println("A photo is clicked.");  
    }  
      
    public void playMsic()   
    {  
        System.out.println("Music is getting Played.");  
    }  
      
    public void pauseMusic()   
    {  
        System.out.println("Music player Paused.");         
    }  
      
    public void stpMusic()   
    {  
        System.out.println("Music player Stopped.");  
    }  
    }  
      
    public class TestInheritance   
    {  
    // main method  
    public static void main(String argvs[])   
    {  
        SmrtPhone sp = new SmrtPhone();  
        sp.setNumber(94863472);  
        System.out.println("Phone number is: " + sp.getNumber());  
        sp.doCall();  
        sp.playMsic();  
        sp.pauseMusic();  
        sp.stpMusic();  
        sp.clickPhoto();  
    }  
    }  

Output:

Count of vowels in the String : '@51#$%290(){}' is: 0
Phone number is: 94863472
Calling the dialled number.
Music is getting Played.
Music player Paused.
Music player Stopped.
A photo is clicked.

14) Demonstrate the basic "divide by 0 exception" with the help of a Java program.

The divide by zero exception occurs when we try to divide a number by 0 in Java. The illustration of the same is mentioned in the following program.

FileName: DivideByZeroException

    import java.util.*;  
    public class DivideByZeroException   
    {  
    // main method  
    public static void main(String argvs[])   
    {  
    Scanner scnr = new Scanner(System.in);  
    int num = scnr.nextInt();  
    System.out.println("The number " + num + " is divided by zero.");  
      
    try   
    {  
        System.out.println(num / 0);  
    }   
    catch(Exception ex)   
    {  
        System.out.println(ex);  
    }  
      
    System.out.println("Program is completed.");  
    }  
    }  

Input:

    3  

Output:

The number 3 is divided by zero.
java.lang.ArithmeticException: / by zero
Program is completed.

Note: In the above program, the try-catch block is used for handling the divide-by-zero exception. Therefore, the program is executed completely. Otherwise, the program would have stopped at the point of exception, and the print statement (Program is completed) would not have been executed.
15) Demonstrate single thread with the help of a Java program.

FileName: MainThreadDemo.java

    public class MainThreadDemo   
    {  
    // main method  
    public static void main(String[] argvs)   
    {  
    // fetching the current thread  
    Thread th = Thread.currentThread();  
      
    // setting the name  
    th.setName("The Main Thread");  
    th.setPriority(7);  
    System.out.println(th);  
    System.out.println(th.getName());  
    System.out.println(th.getPriority());  
      
    }  
    }  

Output:

Thread[The Main Thread,7,main]
The Main Thread
7

16) A string is given to us. Write a program to check whether the string is a palindrome or not. The string can contain white spaces, small and capital letters, and other characters too. Note that the program should be case-insensitive and should ignore the white space and other special characters. For example, a and A will be considered the same character. Also, "a&* A" is a palindrome because we ignore the &,*, and white spaces. Thus, "a&* A" can be written as "aa" as 'a' and 'A' both are the same as far as this question is concerned.

The approach is to traverse the whole string and remove all those characters that are not alphanumeric. Also, remove the white space. Convert all the alphabetical letters to either small or capital letters. After that, with the help of a loop, check whether the updated string is the palindrome or not.

FileName: CheckPalindrome.java

    import java.util.*;  
      
    public class CheckPalindrome   
    {  
      
    // a method that checks whether the string stng is a palindrome or not  
    public static boolean isStrngPalindrome(String stng)   
    {  
      
    // for traversing the string  
    // from beginning and end  
    int l = 0;  
    int h = stng.length() - 1;  
      
    while(l < h)   
    {  
        char c1 = stng.charAt(l);  
        char c2 = stng.charAt(h);  
          
        if(c1 != c2)   
        {  
            return false;  
        }  
          
        l = l + 1;  
        h = h - 1;  
    }  
      
    return true;  
    }  
      
      
    // the following method checks whether the sentence is a palindrome  
    // or not  
    public static boolean isSntncePalindrome(String sntnce)   
    {  
    String reslt = "";  
      
    for(int g = 0; g < sntnce.length(); g++)   
    {  
       // retrieving character at the index g  
       char chr = sntnce.charAt(g);  
         
       // only considering alphanumeric characters and ignoring the other ones   
       if((chr >='a' && chr <= 'z') || (chr >= 'A' && chr <= 'Z') || (chr >= '0' && chr <= '9'))   
       {  
            if(chr >='A' && chr <= 'Z')   
            {  
                reslt = reslt + (char)(chr + 32);  
            }  
            else reslt = reslt + chr;  
       }   
         
       else   
       {  
           // If the control reaches here  
           // then it means the character is not alphanumeric   
           // and therefore, we should ignore it.  
           continue;  
       }  
    }  
      
    if(isStrngPalindrome(reslt))   
    {  
       return true;  
    }  
      
    return false;  
    }  
      
    // main method  
    public static void main(String argvs[])   
    {  
      
    // taking user input  
    Scanner scnr = new Scanner(System.in);  
    String sentnce = scnr.nextLine();  
      
    if(isSntncePalindrome(sentnce))   
    {  
        System.out.println("The string '" + sentnce + "' is a palindrome.");  
    }  
    else   
    {  
        System.out.println("The string '" + sentnce + "' is not a palindrome.");  
    }  
    }  
    }  

Input:

    a&*  B BA b  

Output:

The string 'a&*  B BA b' is not a palindrome.

Input:

    a&*  B BA bB a  

Output:

The string 'a&*  B BA bB a' is a palindrome.

Corner case: It is important to note that we have to convert all the alphabets to either small or capital letters. Also, we need to take care of the case when the user inputs a string that consists of only white spaces. In our case, a string containing only white spaces should be a palindrome.

Complexity Analysis: The time complexity of the program is O(n), where n is the total number of characters present in the string. The space complexity of the program is constant, i.e., O(1).
17) Two binary strings are given to us. Write a Java program to add the given binary string as per the binary addition rules and display the resulting binary string. Note that input strings only contain 0s and 1s and nothing else.

Rules for the binary addition are mentioned below.

    0 + 0 = 0
    0 + 1 = 1
    1 + 0 = 1
    1 + 1 = 0 & c = 1

It is evident by looking at the fourth rule that whenever the result exceeds 1, the answer of addition becomes zero, and carry is 1. shows that whenever the result exceeds 1, the answer of addition becomes 0 and carry becomes 1. Using these four rules, we will do the addition starting from the rightmost index and will move towards the first or the leftmost index. The illustration of it is mentioned in the following program.

FileName: AddBinaryStrings.java

    import java.util.*;  
    public class AddBinaryStrings   
    {  
      
    // adding the binary strings  
    public static String addStrings(String s1, String s2)   
    {  
    String resultantStr = "";  
      
    if(s1.equals("0") && s2.equals("0"))   
    {  
        return "0";  
    }  
      
    // size of the input strings  
    int p = s1.length() - 1;  
    int q = s2.length() - 1;  
      
    int cary = 0;  
      
    // loop that does the binary addition   
    // by addiing digits from right to left  
    while(p >= 0 || q >= 0 || cary > 0)   
    {  
          
        int dig1 = (p >= 0) ? (s1.charAt(p) - '0') : 0;  
        int dig2 = (q >= 0) ? (s2.charAt(q) - '0') : 0;  
          
        int digit = 0;  
        if(dig1 + dig2 + cary >= 2)   
        {  
            digit = (dig1 + dig2 + cary) % 2;  
              
            // handling carry  
            cary = (dig1 + dig2 + cary) / 2;  
        }   
        else   
        {  
            digit = dig1 + dig2 + cary;  
            cary = 0;  
        }  
          
        p = p - 1;  
        q = q - 1;  
        resultantStr  = digit + resultantStr;  
    }  
      
    // returning the final string  
    return resultantStr;  
    }  
      
    // main method  
    public static void main(String argvs[])   
    {  
    // taking input from the user  
    Scanner scnr = new Scanner(System.in);  
    String s1 = scnr.nextLine();  
    String s2 = scnr.nextLine();  
      
    System.out.println("The addition of binary strings is: " + addStrings(s1, s2));    
    }  
    }  

Input:

    11001  
    100  

Output:

The addition of binary strings is: 11101

Input:

    11001  
    111  

Output:

The addition of binary strings is: 100000

Input:

    111111  
    111  

Output:

The addition of binary strings is: 1000110

Corner case: It is important to note that the user can enter strings of any length. It is not mentioned in the question that input strings will be of the same length. Therefore, the length of the first string can be either less or more or equal to the length of the second string. Also, one should note that the final answer may or may not contain an extra bit. For example, 100 + 1 = 101 but, 111 + 111 = 1000. 1000 contains one more bit as compared to the input stings.

Complexity Analysis: The time complexity of the program is O(max(m, n)), where m is the total number of characters present in the first input string, and n is the total number of characters present in the second input string. The space complexity of the program is constant, i.e., O(1).
18) Two strings are given as input. Write a Java program to check whether they are anagrams or not. Two strings are considered anagrams if they have the same characters occurring the same number of times. However, the order in which they occur may or may not be different. For example: "javatpoint", and "ttaaniojvp" are considered as anagrams. Each character presents in "javatpoint" are also there in "ttaaniojvp". Also, the characters which are not present in "javatpoint" are also not there "ttaaniojvp".

We will be using HashMap to store the number of times the characters occur in the first string. Note that character will be the key, and the number of times it occurs is its value. After that, we will traverse the second string and start reducing the frequency of occurrence of characters stored in the HashMap. If the frequency is already zero or the character is absent in the HashMap, we can say that the strings are not anagrams; else, they are anagrams.

FileName: StringAnagrams.java

    import java.util.*;  
    public class StringAnagrams   
    {  
      
    // the following method checks whether string a1 and a2 are anagrams  
    // or not. If yes, a true value is returned. Otherwise, a false value is returned  
    public static boolean isStringsAnagram(String a1, String a2)   
    {  
    // size is not the same. Hence, a false value is returned  
    if(a1.length() != a2.length())  
    {  
    return false;  
    }  
      
    // hashmap for storing the frequency of occurrence of characters  
    // present in the string s1  
    HashMap<Character, Integer> hashMap = new HashMap<Character, Integer>();  
      
    for(int g = 0; g < a1.length(); g++)   
    {  
    int ordrFreq = hashMap.getOrDefault(a1.charAt(g), 0);  
    hashMap.put(a1.charAt(g), ordrFreq + 1);  
    }  
      
    for(int g = 0; g < a2.length(); g++)   
    {  
    if(!hashMap.containsKey(a2.charAt(g)) || hashMap.get(a2.charAt(g)) == 0)   
    {  
        return false;  
    }   
    else   
    {  
        int ordrFreq = hashMap.get(a2.charAt(g));  
        hashMap.put(a2.charAt(g), ordrFreq - 1);  
    }  
    }  
      
    return true;  
    }  
      
    // main method  
    public static void main(String argvs[])   
    {  
    // taking user input  
    Scanner scnr = new Scanner(System.in);  
    String a1 = scnr.nextLine();  
    String a2 = scnr.nextLine();  
      
    if(isStringsAnagram(a1, a2))   
    {  
    System.out.println("Strings '" + a1 + "' & '" + a2 + "' are anagrams.");  
    }  
    else   
    {  
    System.out.println("Strings '" + a1 + "' & '" + a2 + "' are not anagrams.");  
    }  
    }  
    }  

Input:

    javatpoint  
    ttaaniojvp  

Output:

Strings 'javatpoint' & 'ttaaniojvp' are anagrams.

Input:

    india  
    ddiaaa  

Output:

Strings 'india' & 'ddiaaa' are not anagrams.

Corner Cases: It is necessary to check whether the strings are of the same length or not. If not, we can say that the given strings are not anagrams.

Complexity Analysis: The time complexity of the program is O(m + n), where m and n are the sizes of the two strings. The space complexity of the program is O(1).
19) You are given a sorted array of unique integers. It is given that each element in the array is unique. Also, an element is given. Write a Java program to find the index of the element present in the array. If the element is not present in the array, then find the index where it should be put in the array so that the array remains sorted even after putting the element. Note that the program should be optimized in terms of space and time complexity. Consider zero indexing.

It is given in the problem that the array is sorted. So, the best approach is to apply the binary search. The following code is an illustration of it.

FileName: SortedArrayIndex.java

    public class SortedArrayIndex  
    {  
      
    public static int findIndex(int[] numsArr, int tar)   
    {  
    int l = 0;  
    int h = numsArr.length - 1;  
      
    // loop that applies the binary search  
    while(l <= h)   
    {  
    int middle = l + (h - l) / 2;  
      
    // if the element is found  
    // we can return its index  
    if(numsArr[middle] == tar)   
    {  
        return middle;  
    }   
      
    // if the target element is larger than  
    // the numsArr[middle] element, consider the right part of the array  
    // from the index middle  
    else if(numsArr[middle] < tar)   
    {  
        l = middle + 1;  
    }   
      
    // if the target element is less than  
    // the numsArr[middle] element, consider the left part of the array  
    // from the index middle  
    else   
    {  
        h = middle - 1;  
    }  
    }  
      
    return l; // ceiling index is considered  
    }  
      
      
    // main method  
    public static void main(String argvs[])   
    {  
    // input array  
    int[] inputArr = {2, 6, 9, 13, 24, 35, 78, 90, 99};  
    int size = inputArr.length;  
      
    System.out.println("For the input array: ");  
    for(int j = 0; j < size; j++)   
    {  
    System.out.print(inputArr[j] + " ");  
    }  
      
    int tar = 7;  
    int ans = findIndex(inputArr, tar);  
    System.out.println();  
      
    System.out.println("The index of the target element " + tar + " is: " + ans);  
      
    System.out.println(" \n ");  
      
    // input array  
    int[] inputArr1 = {-3, 5, 24, 40, 51, 80, 89, 97};  
    size = inputArr1.length;  
      
    System.out.println("For the input array: ");  
    for(int j = 0; j < size; j++)   
    {  
    System.out.print(inputArr1[j] + " ");  
    }  
      
    tar = 51;  
    ans = findIndex(inputArr1, tar);  
    System.out.println();  
      
    System.out.println("The index of the target element " + tar + " is: " + ans);  
      
    }  
    }  

Output:

For the input array: 
2 6 9 13 24 35 78 90 99 
The index of the target element 7 is: 2
 
 
For the input array: 
-3 5 24 40 51 80 89 97 
The index of the target element 51 is: 4

Complexity Analysis: The time complexity of the program is O(log2(nums)), where nums is the total number of elements present in the input array. The space complexity of the program is O(1), as the program is not using any extra space.
20) An integer array is given to us. Write an optimized Java program to wave-sort the given array.
Java Coding Interview Questions

The main objective is to generate the wave graph. It can be achieved by generating the peaks in the input array or looking at valley generation in the input array. So, we will try to make peaks in the array. We want the first element as the peak element, so the first element remains untouched, and we begin from the second index, leave it as it is and start from the index = 2.
Java Coding Interview Questions

Here, since we want to generate a peak, we need to have the next and previous elements greater than the second element. In the similar fashion, we will have the fourth element smaller than the third and the fifth element.

Thus, we need to take a jump of 2 indices every time until we reach the end of the given array.
Java Coding Interview Questions

FileName: WaveSort.java

    public class WaveSort   
    {  
      
    // swapping elements at the indices a1 and a2  
    public static void swapEle(int[] inputArr, int a1, int a2)   
    {  
    int t = inputArr[a1];  
    inputArr[a1] = inputArr[a2];  
    inputArr[a2] = t;  
    }  
    public static void waveSorting(int[] inputArr)   
    {  
    // loop for doing the wave sort without sorting the input array  
    // taking element at i1 as the peak element and elements that are  
    // adjacent to i1 element will not be the peak element.  
    for(int i1 = 0; i1 < inputArr.length; i1 = i1 + 2)   
    {  
    if(i1 > 0 && inputArr[i1 - 1] > inputArr[i1])   
    {  
        swapEle(inputArr, i1 - 1, i1);  
    }  
      
    if(i1 < inputArr.length - 1 && inputArr[i1 + 1] > inputArr[i1])   
    {  
        swapEle(inputArr, i1, i1 + 1);  
    }  
    }  
    }  
      
    // main method  
    public static void main(String argvs[])   
    {  
    // input array - 1  
    int[] inputArr = {19, 18, 16, 13, 14, 17, 12};  
      
    int size = inputArr.length;  
      
    System.out.println("The input array is: ");  
      
    for(int i1 = 0; i1 < size; i1++)   
    {  
    System.out.print(inputArr[i1] + " ");  
    }  
      
    System.out.println( "\n ");  
    waveSorting(inputArr);  
      
    System.out.println("After the wave sort");  
      
    for(int i1 = 0; i1 < inputArr.length; i1++)   
    {  
    System.out.print(inputArr[i1] + " ");  
    }  
      
    System.out.println( "\n ");  
      
    // input array - 2  
    int[] inputArr1 = {-45, 45, -50, -60, 0, 34, 9, 12};  
      
    size = inputArr1.length;  
      
    System.out.println("The input array is: ");  
      
    for(int i1 = 0; i1 < size; i1++)   
    {  
    System.out.print(inputArr1[i1] + " ");  
    }  
      
    System.out.println( "\n ");  
    waveSorting(inputArr1);  
      
    System.out.println("After the wave sort");  
      
    for(int i1 = 0; i1 < inputArr1.length; i1++)   
    {  
    System.out.print(inputArr1[i1] + " ");  
    }  
    }  
    }  

Output:

The input array is: 
19 18 16 13 14 17 12 
 
After the wave sort
19 16 18 13 17 12 14 
 
The input array is: 
-45 45 -50 -60 0 34 9 12 
 
After the wave sort
45 -50 -45 -60 34 0 12 9

Complexity Analysis: The time complexity of the program is O(nums), where nums is the total number of elements present in the input array. The space complexity of the program is O(1), as the program is not using any extra space.

Corner Case: In the code, the previous and the next element are getting swapped; thus, it is required to take care of the index out-of-bounds condition.
Note 1: The output shown above is not the only answer. For this problem, there can be other answers too. One has to show any one of them.
Note 2: Another solution is to sort the array and then swap the adjacent element to get the answer. However, it can lead to O(nums * log(nums)) time complexity, and the solution provided above is more optimized and has O(nums) time complexity. Therefore, the sorting approach is not discussed above, as we have to write the most optimized program.
21) Create a user-defined exception and demonstrate its working (when it raises an exception) with the help of a Java program.

In the following program, A class called LowBalanceExcptn is created for the bank. Therefore, when a person creates a bank account, the minimum balance the person should maintain Rs. 7000. Therefore, when the bank balance becomes less than Rs. 7000, the exception is raised. The illustration of the same is mentioned below.

FileName: BankBlance.java

    public class BankBlance   
    {  
    // main method  
    public static void main(String[] argvs)   
    {  
    BankAccount acnt1 = new BankAccount(500);  
    BankAccount acnt2 = new BankAccount();  
    acnt2.setBalance(500);  
      
    BankAccount acnt3 = new BankAccount(10000);  
      
    System.out.println("account - 1 balance = " + acnt1.getBlnce());  
    System.out.println("account - 2 balance = " + acnt2.getBlnce());  
    System.out.println("account - 3 balance = " + acnt3.getBlnce());  
    }  
    }  
      
    class BankAccount   
    {  
     private int blnce;  
       
    // constructor of the class  
    BankAccount()   
    {  
      
    blnce = 7000;  
    }  
      
    // parameterized constructor of the class  
    BankAccount(int blnce)   
    {  
    try   
    {  
    if(blnce >= 7000)   
    {  
    this.blnce = blnce;  
    System.out.println("The bank account is created and the balance is set to: "+ blnce);  
    }   
    else   
    {  
    this.blnce = 0;  
    System.out.println("The account can't be created.");  
    throw new LowBalanceExcption();  
    }  
    }   
    catch(LowBalanceExcption e)   
    {  
    System.out.println(e);  
    }  
      
    }  
       
    void setBalance(int balance)   
    {  
    // try catch block for   
    // handling the exception  
    try   
    {  
    if(blnce >= 7000)   
    {  
    this.blnce = blnce;  
    System.out.println("The account has been created and the bank balance has set to: "+ blnce);  
    }   
    else   
    {  
    this.blnce = 0;  
    System.out.println(" The account can't be created.");  
      
    // reaching here means a custom exception has been raised  
    // as the bank balance is less than 7000  
    throw new LowBalanceExcption();  
    }  
      
    }   
    catch(LowBalanceExcption e)   
    {  
       System.out.println(e);  
    }  
    }  
       
    // get the balance  
    int getBlnce()   
    {  
    return blnce;  
    }  
    }  
      
    class LowBalanceExcption extends Exception   
    {  
    // message to be printed when the LowBalanceExcption is raised.  
    public String toString()   
    {  
      return "Account has the low balance: The bank balance can never be less than Rs.7000/-";  
    }  
    }  

Output:

The account can't be created.
Account has the low balance: The bank balance can never be less than Rs.7000/-
The account has been created and the bank balance has set to: 7000
The bank account is created and the balance is set to: 10000
account - 1 balance = 0
account - 2 balance = 7000
account - 3 balance = 10000

22) Show Multiple Inheritance using a Java program.

In Java, it is not possible to have multiple inheritance. Therefore, we need to take the help of interfaces to make a multiple inheritance scenario. In the following example, a class called DemoClass is created that implements multiple interfaces, and by doing this, multiple inheritance is achieved.

FileName: TestClass.java

    // first Interface  
    interface Interface1   
    {  
      
    // printMessage is the default method  
    default void printMessage()  
    {  
      
    // message for the first interface  
    System.out.println("Default Interface1");  
    }  
    }  
      
    // Second Interface   
    interface Interface2 {  
      
    // printMessage is the default method  
    default void printMessage()  
    {  
      
    // message for the second interface  
    System.out.println("Default Interface2");  
    }  
    }  
      
    // Main class that implements Interface2, and Interface1  
    public class TestClass implements Interface1, Interface2   
    {  
      
    // Overriding the default printMessage method  
    @Override  
    public void printMessage()  
    {  
      
    // Using the keyword super to invoke the printMessage()  
    // method of the interface Interface1  
    // In the main method, it should not be used directly;  
    Interface1.super.printMessage();  
      
    // Using keyword super to invoke the printMessage()  
    // method of the interface Interface2  
    // In the main method, it should not be used directly;  
    Interface2.super.printMessage();  
    }  
      
    // Method for only executing the   
    // method  printMessage() of Interface1  
    public void showOfInterface1()   
    {  
      
    Interface1.super.printMessage();  
    }  
      
    // Method for only executing the method  
    // printMessage() of Interface2  
    public void showOfInterface2()   
    {  
    // In the main method, it should not be used directly.  
    Interface2.super.printMessage();   
    }  
      
    // Main method  
    public static void main(String argvs[])  
    {  
      
    // Creating an object of the class TestClass  
    TestClass tc = new TestClass();  
    tc.printMessage();  
    System.out.println("Now Executing methods showOfInterface1() showOfInterface2()");  
    tc.showOfInterface1();  
    tc.showOfInterface2();  
    }  
    }  

Output:

Default Interface1
Default Interface2
Now Executing methods showOfInterface1() showOfInterface2()
Default Interface1
Default Interface2

Note: If one removes the default method implementation from the class "TestClass", a compilation error is raised. If there exists a diamond through interfaces, then it is not an issue if the middle interfaces is not providing implementation of the topmost interface. If the middle interfaces provide an implementation, then the implementation can be fetched using the keyword super keyword.
23) Demonstrate nesting of classes using a Java program.

Defining a class inside another class is known as nesting of classes. Usually, in Java, the inner class is the static class. Observe the following program.

FileName: NestedClass.java

    public class NestedClass  
    {  
      
    // main method       
    public static void main(String argvs[])   
    {  
    // instantiating the outer class  
    OuterClass ob1 = new OuterClass(10, 20);  
      
    // instating the second inner class  
    OuterClass.InnerClass2 ob2 = new OuterClass.InnerClass2(40);  
    ob2.displayData();  
      
    OuterClass.InnerClass3.z1 = 101;  
    System.out.println(OuterClass.InnerClass3.z1);  
      
    // instating the third inner class  
    OuterClass.InnerClass3 ob3 = new OuterClass.InnerClass3(409);  
    ob3.displayData();  
    }  
       
    }  
      
    class OuterClass   
    {  
      
     private int x1;  
     private int y1;  
           
    // parameterless constructor  
    OuterClass()   
    {  
    System.out.println("The default constructor of the Outer class is invoked.");  
    }  
      
    // parameterized constructor  
    OuterClass(int x1, int y1)   
    {  
     this.x1 = x1;  
     this.y1 = y1;  
     System.out.println("The parameterized constructor of the Outer class is invoked.");  
    }  
      
    void displayData()   
    {  
     System.out.println("X = " + x1 + " and Y = " + y1);  
    }  
      
    class InnerClass1   
    {  
      
     int z1 = 0;  
      
     InnerClass1()   
     {  
       System.out.println("The default constructor invoked of the first inner class.");  
     }  
      
     // parameterized constructor of the   
     // first inner class  
     InnerClass1(int z1)   
     {  
        this.z1 = z1;  
     }  
      
     void displayData()   
     {  
        System.out.println("X = " + x1 + " Y = " + y1 + " and Z = " + z1);  
     }  
    }  
      
    // the second inner class  
    static class InnerClass2   
    {  
      
    int z1 = 0;  
      
    InnerClass2()   
    {  
    System.out.println("The default constructor invoked of the second inner class.");  
    }  
      
    // parameterized constructor of the   
    // second inner class  
    InnerClass2(int z1)   
    {  
    this.z1 = z1;  
    System.out.println("The parameterized constructor invoked of the second inner class.");  
    }  
      
    void displayData()   
    {  
    System.out.println("Z = " + z1);  
    }  
    }  
          
    // the third inner class  
    static class InnerClass3   
    {  
      
    static int z1 = 0;  
      
    InnerClass3()   
    {  
    System.out.println("The default constructor invoked of the third inner class.");  
    }  
      
    // parameterized constructor of the   
    // third inner class  
    InnerClass3(int a1)   
    {  
    z1 = a1;  
    System.out.println("The parameterized constructor invoked of the third inner class.");  
    }  
      
    void displayData()   
    {  
    System.out.println("Z = " + z1);  
    }  
    }  
    }  

Output:

The parameterized constructor of the Outer class is invoked.
The parameterized constructor invoked of the second inner class.
Z = 40
101
The parameterized constructor invoked of the third inner class.
Z = 409

24) Demonstrate the Diamond Problem using a Java program.

A diamond problem is a problem of multiple inheritances where one class extends two or more classes. In other words, when a child class has more than one parent class, then an error occurs. The diamond problem using a Java program is discussed below.

FileName: DiamondProblem.java

    class P1   
    {  
    public void display()   
    {  
    System.out.println("Inside the display method of the class P1.");  
    }  
    }  
      
    class C1 extends P1  
    {  
    @Override  
    public void display()   
    {  
    System.out.println("Inside the display method of the class C1.");  
    }  
    }  
      
    class C2 extends P1  
    {  
    @Override  
    public void display()   
    {  
    System.out.println("Inside the display method of the class C2.");  
    }  
    }  
      
    // In Java, multiple inheritance is prohibited  
    class GC1 extends C1,C2  
    {  
    @Override   
    public void display()   
    {  
    System.out.println("Inside the display method of the class GC1.");  
    }  
    }  
      
    public class DiamondProblem   
    {  
      
    // main method  
    public static void main(String argvs[])   
    {  
    // creating an object of the class  
    // GC1  
    GC1 obj = new GC1();  
    obj.display(); // display() method of the class GC1 is invoked   
    }  
    }  

Output:

/DiamondProblem.java:28: error: '{' expected
class GC1 extends C1,C2
                    ^
1 error

Explanation: The problem with the above code is when we override the display() method in class GC1 which method is overridden, the compiler does not know whether the class C1 display() method is overridden or of the class C2 display() method is overridden.
25) Demonstrate the operations isAlive() or join() in the multithreading.

The method isAlive() gives information about a thread, whether it is terminated or alive. These terminated and alive are the thread states in Java. Also, the operation join() joins a thread with another, which means that a thread will have to wait for the completion of the thread to which it is joined, even if the thread has accomplished its own work. Together both will terminate.

FileName: DemoClass.java

    class DemoThread1 extends Thread   
    {  
      
    public DemoThread1(String n)   
    {  
    super(n);  
    setPriority(MAX_PRIORITY);  
    }  
    }  
      
    class DemoThread2 extends Thread   
    {  
      
    @Override    
    public void run()   
    {  
    int cnt = 1;  
    while (true)   
    {  
    System.out.println(cnt);  
    cnt = cnt + 1;  
    // if the value of cnt is more than 6  
    // loop is terminated  
    if(cnt > 6)  
    {  
       break;  
    }  
    try   
    {  
        Thread.sleep(100);  
    }   
      
    catch (InterruptedException ex)   
    {  
        System.out.println(ex);  
    }  
    }  
    }  
    }  
      
    // main class  
    public class DemoClass  
    {  
    // main method  
    public static void main(String[] argvs)   
    {  
      
    // creating thread   
    DemoThread1 th = new DemoThread1("first Thread ");  
      
    // various print statements  
    System.out.println("Thread id: " + th.getId());  
    System.out.println("Thread name: " + th.getName());  
    System.out.println("Thread priority: " + th.getPriority());  
    th.start();  
    System.out.println("Thread State: " + th.getState());  
    System.out.println("Thread alive: " + th.isAlive());  
      
    // creating thread  
    DemoThread2 th2 = new DemoThread2();  
    try   
    {  
     Thread.sleep(100);  
    }   
      
    catch (Exception ex)   
    {  
       
    }  
      
    th2.setDaemon(true);  
    th2.start();  
      
      
    try   
    {  
       
      th.join();   
      th2.join();  
    }   
      
    catch (Exception ex)   
    {  
      
    }  
    }  
    }  

Output:

Thread id: 14
Thread name: first Thread 
Thread priority: 10
Thread State: RUNNABLE
Thread alive: false
1
2
3
4
5
6

26) Demonstrate Thread Synchronization using a Java program.

We can achieve thread synchronization with the help of the synchronization keyword. The following is an example program.

FileName: ThreadSynchronization.java

    class TableClass   
    {  
    // because the keyword synchronized only one   
    // string will enter the method, and the second   
    // string will have to wait for the first thread to  
    // finish its job. After that, the second thread takes  
    // the control.  
    public synchronized void display(int num)   
    {  
    //   
    for (int j = 1; j <= 10; j++)   
    {  
    System.out.print(num * j + " ");  
    }  
    System.out.println( );  
    }  
    }  
      
    class ThreadCl1 extends Thread   
    {  
     TableClass tc;   
           
    public ThreadCl1(TableClass tc)   
    {  
      this.tc = tc;  
    }  
    // inside the run method   
    // display() method is invoked  
    public void run()   
    {  
      tc.display(11);  
    }  
    }  
      
    class ThreadCl2 extends Thread   
    {  
    TableClass tc;  
    public ThreadCl2(TableClass tc)   
    {  
    this.tc = tc;  
    }  
    // inside the run method   
    // display() method is invoked  
    public void run()   
    {  
    tc.display(12);  
    }  
    }  
    // main class  
    public class ThreadSynchronization   
    {  
    // main method  
    public static void main(String argvs[])   
    {  
    // instantiating the class TableClass  
    TableClass tClass = new TableClass();  
    // creating the first thread  
    ThreadCl1 thd1 = new ThreadCl1(tClass);  
      
    // creating the second thread  
    ThreadCl2 thd2 = new ThreadCl2(tClass);  
    thd1.start();  
    thd2.start();  
    }  
    }  

Output:

11 22 33 44 55 66 77 88 99 110 
12 24 36 48 60 72 84 96 108 120

27) Demonstrate a deadlock scenario with the help of a Java program.

Whenever there is a scenario where two or more than two threads are locked forever, then that scenario is a deadlock scenario. Deadlocks usually occur in a multi-threaded environment. The following program gives demonstration of a deadlock scenario:

FileName: ThreadSynchronization.java

    // main class  
    public class ThreadSynchronization   
    {  
      
    // main  method  
    public static void main(String argvs[]) throws InterruptedException   
    {  
        Object ob1 = new Object();  
        Object ob2 = new Object();  
        Object ob3 = new Object();  
      
        // creating three threads  
        Thread th1 = new Thread(new SynThread(ob1, ob2), "th1");  
        Thread th2 = new Thread(new SynThread(ob2, ob3), "th2");  
        Thread th3 = new Thread(new SynThread(ob3, ob1), "th3");  
      
        // start all the three threads  
        th1.start();  
        Thread.sleep(500);  
        th2.start();  
        Thread.sleep(500);  
        th3.start();          
    }  
      
    }  
      
    class SynThread implements Runnable   
    {  
      
    private Object ob1;  
    private Object ob2;  
      
    public SynThread(Object ob1, Object ob2)   
    {  
        this.ob1 = ob1;  
        this.ob2 = ob2;  
    }  
      
    @Override  
    public void run()   
    {  
    String strName = Thread.currentThread().getName();  
      
    System.out.println(strName + " is taking control on the lock " + ob1);  
      
    // lock on the first object  
    synchronized (ob1)   
    {  
        System.out.println(strName + " acquired the lock on " + ob1);  
        work();  
        System.out.println(strName + " iz taking control on the lock " + ob2);  
    synchronized (ob2)   
    {  
        // because of the deadlock the following print statement will not work  
        System.out.println(strName + " acquired the lock on " + ob2);  
        work();  
    }  
    System.out.println(strName + " released the lock on " + ob2); // will not work  
    }  
    System.out.println(strName + " released the lock on " + ob1); // will not work  
    System.out.println(strName + " finished the execution."); // will not work  
    }  
      
    private void work()   
    {  
    try   
    {  
        Thread.sleep(40000);  
    }   
    catch (InterruptedException ie)   
    {  
        ie.printStackTrace();  
    }  
    }  
      
    }  

Output:

th1 is taking control on the lock java.lang.Object@256f00b6
th1 acquired the lock on java.lang.Object@256f00b6
th2 is taking control on the lock java.lang.Object@5cdddb56
th2 acquired the lock on java.lang.Object@5cdddb56
th3 is taking control on the lock java.lang.Object@248f4cc7
th3 acquired the lock on java.lang.Object@248f4cc7

Explanation: All of the three threads are able to take a lock on the first object. But, they are also using the resources that is shared and are started in a way that the threads keep on indefinitely waiting in order to acquire the lock on the second object.
28) Solve the Sudoku puzzle with the help of a Java program.

A sudoku puzzle is a popular Japanese puzzle that is based on the logical positioning of numbers from 1 to 9. The task is to fill the 9 x 9 grid with numbers from 1 to 9 such that all columns, rows and sub-grids (there will be 9 sub-grids of 3 x 3) contain each number from 1 to 9 with zero repeats. The program for solving the sudoku is mentioned below.

FileName: Sudoku.java

    public class Sudoku   
    {  
      
    // M is the size of the M * M 2D matrix  
    static int M = 9;  
      
    // Takes a grid that is partially filled in and tries  
    // to assign values to all of the unassigned locations in  
    // a way to fulfil the conditions of the  
    // Sudoku solution, which is zero duplication of numbers   
    // in every row, column, and sub-grid.  
    static boolean solveSudokuPuzzle(int sudokuGrid[][], int r, int c)  
    {  
      
    // if one has reached the 9th  
    // column and 9th row(consider the matrix zero-indexed)  
    // A true value is returned in order to avoid further  
    // backtracking   
    if (r == M - 1 && c == M)  
    {  
    return true;  
    }  
      
    // Check if the column value becomes 9,  
    // we move to the next row  
    // and column start from 0  
    if (c == M)   
    {  
    r = r + 1;  
    c = 0;  
    }  
      
    // Check whether the current position  
    // of the sudoku grid already  
    // contains a value greater than 0, we loop  
    // for the next column  
    if (sudokuGrid[r][c] != 0)  
    {  
    return solveSudokuPuzzle(sudokuGrid, r, c + 1);  
    }  
      
    for (int n = 1; n < 10; n++)   
    {  
      
    // Check if it is safe to place  
    // the n (1-9) in the  
    // given row ,col ->we move to next column  
    if (isSafe(sudokuGrid, r, c, n))   
    {  
      
        // assign the value n in the current  
        // (r,c) position of the sudoku grid and  
        // assume that the assigned value of n in the position  
        // is valid.  
        sudokuGrid[r][c] = n;  
      
        // Checking for the next  
        // possibility with the next column  
        if (solveSudokuPuzzle(sudokuGrid, r, c + 1))  
        {  
            return true;  
        }  
    }  
    // removing the assigned n, since whatever was the  
    // assumption turns out to be wrong, and hence look for the next  
    // assumption with diff value of n value  
    sudokuGrid[r][c] = 0;  
    }  
    return false;  
    }  
      
    // A utility method for printing the grid  
    static void print(int sudokuGrid[][])  
    {  
    for (int j = 0; j < M; j++)   
    {  
    for (int k = 0; k < M; k++)  
    {  
        System.out.print(sudokuGrid[j][k] + " ");  
    }  
    System.out.println( );  
    }  
    }  
      
    // Checking whether it is valid  
    // to assign the value n to the given   
    // given r, c  
    static boolean isSafe(int[][] sudokuGrid, int r, int c, int n)  
    {  
      
    // Checking if the same value of n is found  
    // in the similar row , if it is found a  
    // false value is returned  
    for (int row = 0; row <= 8; row++)  
    {  
    if (sudokuGrid[r][row] == n)  
    {  
        return false;  
    }  
    }  
      
    // Check if we find the same num  
    // in the similar column ,  
    // we return false  
    for (int col = 0; col <= 8; col++)  
    {  
    if (sudokuGrid[col][c] == n)  
    {  
        return false;  
    }  
    }  
      
    // Checking if the same value of n is  
    // found in the the particular 3 x 3 sub-grid  
    // if found a false value is returned  
    int startR = r - r % 3;  
    int startC = c - c % 3;  
    for (int j = 0; j < 3; j++)  
    {  
    for (int k = 0; k < 3; k++)  
    {  
        if (sudokuGrid[j + startR][k + startC] == n)  
        {  
                    return false;  
        }  
    }  
    }  
      
    return true;  
    }  
      
    // main method  
    public static void main(String[] args)  
    {  
    // 9 x 9 sudoku grid  
    // 0 means that place is empty and the player will put  
    // numbers only in the empty space, i.e., only at those places  
    // where 0 is mentioned.  
    int sudokuGrid[][] = { { 5, 3, 0, 0, 7, 0, 0, 0, 0 },  
                 { 6, 0, 0, 1, 9, 5, 0, 0, 0 },  
                 { 0, 9, 8, 0, 0, 0, 0, 6, 0 },  
                 { 8, 0, 0, 0, 6, 0, 0, 0, 3 },  
                 { 4, 0, 0, 8, 0, 3, 0, 0, 1 },  
                 { 7, 0, 0, 0, 2, 0, 0, 0, 6 },  
                 { 0, 6, 0, 0, 0, 0, 2, 8, 0 },  
                 { 0, 0, 0, 4, 1, 9, 0, 0, 5 },  
                 { 0, 0, 0, 0, 8, 0, 0, 7, 9 } };  
      
    if (solveSudokuPuzzle(sudokuGrid, 0, 0))  
    {  
    print(sudokuGrid);  
    }  
    else  
    {  
    System.out.println("The solution is not found!");  
    }  
    }  
    }  

Output:

5 3 4 6 7 8 9 1 2 
6 7 2 1 9 5 3 4 8 
1 9 8 3 4 2 5 6 7 
8 5 9 7 6 1 4 2 3 
4 2 6 8 5 3 7 9 1 
7 1 3 9 2 4 8 5 6 
9 6 1 5 3 7 2 8 4 
2 8 7 4 1 9 6 3 5 
3 4 5 2 8 6 1 7 9

Time complexity: In the worst case, it is required to put every number in the empty cell and check whether it is a valid one or not. Thus, there are 9 choices for every cell, making the time complexity O(9^(n x n)).

Auxiliary Space: O(n x n).


You may also like:

    Java Interview Questions
    SQL Interview Questions
    Python Interview Questions
    JavaScript Interview Questions
    Angular Interview Questions
    Selenium Interview Questions
    Spring Boot Interview Questions
    HR Interview Questions
    C Programming Interview Questions
    C++ Interview Questions
    Data Structure Interview Questions
    DBMS Interview Questions
    HTML Interview Questions
    IAS Interview Questions
    Manual Testing Interview Questions
    OOPs Interview Questions
    .Net Interview Questions
    C# Interview Questions
    ReactJS Interview Questions
    Networking Interview Questions
    PHP Interview Questions
    CSS Interview Questions
    Node.js Interview Questions
    Spring Interview Questions
    Hibernate Interview Questions
    AWS Interview Questions
    Accounting Interview Questions

Learn Latest Tutorials
Splunk tutorial

Splunk
SPSS tutorial

SPSS
Swagger tutorial

Swagger
T-SQL tutorial

Transact-SQL
Tumblr tutorial

Tumblr
React tutorial

ReactJS
Regex tutorial

Regex
Reinforcement learning tutorial

Reinforcement Learning
R Programming tutorial

R Programming
RxJS tutorial

RxJS
React Native tutorial

React Native
Python Design Patterns

Python Design Patterns
Python Pillow tutorial

Python Pillow
Python Turtle tutorial

Python Turtle
Keras tutorial

Keras
Preparation
Aptitude

Aptitude
Logical Reasoning

Reasoning
Verbal Ability

Verbal Ability
Interview Questions

Interview Questions
Company Interview Questions

Company Questions
Trending Technologies
Artificial Intelligence Tutorial

Artificial Intelligence
AWS Tutorial

AWS
Selenium tutorial

Selenium
Cloud Computing tutorial

Cloud Computing
Hadoop tutorial

Hadoop
ReactJS Tutorial

ReactJS
Data Science Tutorial

Data Science
Angular 7 Tutorial

Angular 7
Blockchain Tutorial

Blockchain
Git Tutorial

Git
Machine Learning Tutorial

Machine Learning
DevOps Tutorial

DevOps
B.Tech / MCA
DBMS tutorial

DBMS
Data Structures tutorial

Data Structures
DAA tutorial

DAA
Operating System tutorial

Operating System
Computer Network tutorial

Computer Network
Compiler Design tutorial

Compiler Design
Computer Organization and Architecture

Computer Organization
Discrete Mathematics Tutorial

Discrete Mathematics
Ethical Hacking Tutorial

Ethical Hacking
Computer Graphics Tutorial

Computer Graphics
Software Engineering Tutorial

Software Engineering
html tutorial

Web Technology
Cyber Security tutorial

Cyber Security
Automata Tutorial

Automata
C Language tutorial

C Programming
C++ tutorial

C++
Java tutorial

Java
.Net Framework tutorial

.Net
Python tutorial

Python
List of Programs

Programs
Control Systems tutorial

Control System
Data Mining Tutorial

Data Mining
Data Warehouse Tutorial

Data Warehouse
